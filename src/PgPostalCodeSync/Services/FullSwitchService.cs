using Microsoft.Extensions.Logging;
using Npgsql;

namespace PgPostalCodeSync.Services;

public interface IFullSwitchService
{
    Task<FullSwitchResult> PerformFullReplacementAsync(string connectionString, long runId, CancellationToken cancellationToken = default);
}

public class FullSwitchService : IFullSwitchService
{
    private readonly ILogger<FullSwitchService> _logger;

    public FullSwitchService(ILogger<FullSwitchService> logger)
    {
        _logger = logger;
    }

    public async Task<FullSwitchResult> PerformFullReplacementAsync(string connectionString, long runId, CancellationToken cancellationToken = default)
    {
        var result = new FullSwitchResult();
        var startTime = DateTime.UtcNow;

        _logger.LogInformation("Starting full replacement process");

        await using var connection = new NpgsqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        try
        {
            await CleanupOldNewTablesAsync(connection, cancellationToken);

            var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
            var newTableName = $"postal_codes_new_{timestamp}";
            var backupTableName = $"postal_codes_old_{timestamp}";

            result.NewTableName = newTableName;
            result.BackupTableName = backupTableName;

            await CreateNewTableAsync(connection, newTableName, cancellationToken);
            _logger.LogInformation("Created new table: {TableName}", newTableName);

            result.ImportedRows = await PopulateNewTableAsync(connection, newTableName, runId, cancellationToken);
            _logger.LogInformation("Populated new table with {Rows} rows", result.ImportedRows);

            await CreateIndexOnNewTableAsync(connection, newTableName, cancellationToken);
            _logger.LogInformation("Created index on new table");

            await AnalyzeNewTableAsync(connection, newTableName, cancellationToken);
            _logger.LogInformation("Analyzed new table statistics");

            var switchSuccess = await AtomicTableSwitchAsync(connection, newTableName, backupTableName, cancellationToken);
            if (!switchSuccess)
            {
                throw new InvalidOperationException("Failed to acquire lock for table switch within timeout");
            }

            _logger.LogInformation("Atomic table switch completed successfully");

            await CleanupOldBackupTablesAsync(connection, cancellationToken);

            result.Success = true;
            result.Duration = DateTime.UtcNow - startTime;

            _logger.LogInformation("Full replacement completed successfully in {Duration}ms", 
                result.Duration.TotalMilliseconds);

            return result;
        }
        catch (Exception ex)
        {
            result.Success = false;
            result.Error = ex.Message;
            result.Duration = DateTime.UtcNow - startTime;

            _logger.LogError(ex, "Full replacement failed: {Error}", ex.Message);

            try
            {
                await CleanupFailedAttemptAsync(connection, result.NewTableName, cancellationToken);
                await CleanupOldNewTablesAsync(connection, cancellationToken);
            }
            catch (Exception cleanupEx)
            {
                _logger.LogError(cleanupEx, "Failed to cleanup after failed full replacement");
            }

            throw;
        }
    }

    private async Task CreateNewTableAsync(NpgsqlConnection connection, string newTableName, CancellationToken cancellationToken)
    {
        var createCommand = $"""
            CREATE TABLE ext.{newTableName} (
                id BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
                postal_code character(7) DEFAULT '' NOT NULL,
                prefecture_katakana TEXT DEFAULT '' NOT NULL,
                city_katakana TEXT DEFAULT '' NOT NULL,
                town_katakana TEXT DEFAULT '' NOT NULL,
                prefecture TEXT DEFAULT '' NOT NULL,
                city TEXT DEFAULT '' NOT NULL,
                town TEXT DEFAULT '' NOT NULL,
                run_id BIGINT,
                CONSTRAINT {newTableName}_PKC PRIMARY KEY (id)
            )
            """;

        await using var command = new NpgsqlCommand(createCommand, connection);
        await command.ExecuteNonQueryAsync(cancellationToken);
    }

    private async Task<long> PopulateNewTableAsync(NpgsqlConnection connection, string newTableName, long runId, CancellationToken cancellationToken)
    {
        var insertCommand = $"""
            INSERT INTO ext.{newTableName} 
                (postal_code, prefecture_katakana, city_katakana, town_katakana, prefecture, city, town, run_id)
            SELECT 
                l.zip_code7,
                l.prefecture_katakana,
                l.city_katakana,
                l.town_katakana,
                l.prefecture,
                l.city,
                l.town,
                {runId}
            FROM ext.postal_codes_landed l
            """;

        await using var command = new NpgsqlCommand(insertCommand, connection);
        command.CommandTimeout = 600;

        var insertedRows = await command.ExecuteNonQueryAsync(cancellationToken);
        return insertedRows;
    }

    private async Task CreateIndexOnNewTableAsync(NpgsqlConnection connection, string newTableName, CancellationToken cancellationToken)
    {
        var indexCommand = $"""
            CREATE INDEX IF NOT EXISTS ix_{newTableName}_comp
            ON ext.{newTableName} (postal_code, prefecture, city, town)
            """;

        await using var command = new NpgsqlCommand(indexCommand, connection);
        command.CommandTimeout = 600;
        
        await command.ExecuteNonQueryAsync(cancellationToken);
    }

    private async Task AnalyzeNewTableAsync(NpgsqlConnection connection, string newTableName, CancellationToken cancellationToken)
    {
        var analyzeCommand = $"ANALYZE ext.{newTableName}";

        await using var command = new NpgsqlCommand(analyzeCommand, connection);
        await command.ExecuteNonQueryAsync(cancellationToken);
    }

    private async Task<bool> AtomicTableSwitchAsync(NpgsqlConnection connection, string newTableName, string backupTableName, CancellationToken cancellationToken)
    {
        const int maxRetryAttempts = 3;
        const int retryDelayMs = 1000;

        for (int attempt = 1; attempt <= maxRetryAttempts; attempt++)
        {
            _logger.LogInformation("Attempting atomic table switch (attempt {Attempt}/{MaxAttempts})", attempt, maxRetryAttempts);

            await using var transaction = await connection.BeginTransactionAsync(cancellationToken);
            
            try
            {
                await using var lockTimeoutCommand = new NpgsqlCommand("SET LOCAL lock_timeout = '5s'", connection, transaction);
                await lockTimeoutCommand.ExecuteNonQueryAsync(cancellationToken);

                await using var renameOldCommand = new NpgsqlCommand($"ALTER TABLE ext.postal_codes RENAME TO {backupTableName}", connection, transaction);
                await renameOldCommand.ExecuteNonQueryAsync(cancellationToken);

                await using var renameNewCommand = new NpgsqlCommand($"ALTER TABLE ext.{newTableName} RENAME TO postal_codes", connection, transaction);
                await renameNewCommand.ExecuteNonQueryAsync(cancellationToken);

                await transaction.CommitAsync(cancellationToken);
                
                _logger.LogInformation("Atomic table switch successful on attempt {Attempt}", attempt);
                return true;
            }
            catch (Exception ex) when (ex.Message.Contains("lock_timeout") || ex.Message.Contains("timeout"))
            {
                _logger.LogWarning("Lock timeout on attempt {Attempt}: {Message}", attempt, ex.Message);
                
                try
                {
                    await transaction.RollbackAsync(cancellationToken);
                }
                catch (Exception rollbackEx)
                {
                    _logger.LogError(rollbackEx, "Error during transaction rollback");
                }

                if (attempt < maxRetryAttempts)
                {
                    await Task.Delay(retryDelayMs, cancellationToken);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error during atomic table switch: {Message}", ex.Message);
                
                try
                {
                    await transaction.RollbackAsync(cancellationToken);
                }
                catch (Exception rollbackEx)
                {
                    _logger.LogError(rollbackEx, "Error during transaction rollback");
                }

                throw;
            }
        }

        _logger.LogError("Failed to perform atomic table switch after {MaxAttempts} attempts", maxRetryAttempts);
        return false;
    }

    private async Task CleanupOldBackupTablesAsync(NpgsqlConnection connection, CancellationToken cancellationToken)
    {
        const int keepTables = 3;

        var getTablesCommand = """
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = 'ext' 
                AND table_name LIKE 'postal_codes_old_%'
            ORDER BY table_name DESC
            """;

        var tableNames = new List<string>();
        await using var command = new NpgsqlCommand(getTablesCommand, connection);
        await using var reader = await command.ExecuteReaderAsync(cancellationToken);
        
        while (await reader.ReadAsync(cancellationToken))
        {
            tableNames.Add(reader.GetString(0));
        }

        if (tableNames.Count <= keepTables)
            return;

        var tablesToDrop = tableNames.Skip(keepTables);
        
        foreach (var tableName in tablesToDrop)
        {
            try
            {
                await using var dropCommand = new NpgsqlCommand($"DROP TABLE IF EXISTS ext.{tableName}", connection);
                await dropCommand.ExecuteNonQueryAsync(cancellationToken);
                
                _logger.LogInformation("Dropped old backup table: {TableName}", tableName);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to drop old backup table {TableName}: {Error}", tableName, ex.Message);
            }
        }
    }

    private async Task CleanupFailedAttemptAsync(NpgsqlConnection connection, string? newTableName, CancellationToken cancellationToken)
    {
        if (string.IsNullOrEmpty(newTableName))
            return;

        try
        {
            await using var dropTableCommand = new NpgsqlCommand($"DROP TABLE IF EXISTS ext.{newTableName} CASCADE", connection);
            await dropTableCommand.ExecuteNonQueryAsync(cancellationToken);
            
            _logger.LogInformation("Cleaned up failed attempt table: {TableName}", newTableName);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to cleanup table {TableName}: {Error}", newTableName, ex.Message);
        }
    }

    private async Task CleanupOldNewTablesAsync(NpgsqlConnection connection, CancellationToken cancellationToken)
    {
        try
        {
            var getTablesCommand = """
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'ext' 
                    AND table_name LIKE 'postal_codes_new_%'
                ORDER BY table_name DESC
                """;

            var tableNames = new List<string>();
            await using var command = new NpgsqlCommand(getTablesCommand, connection);
            await using var reader = await command.ExecuteReaderAsync(cancellationToken);
            
            while (await reader.ReadAsync(cancellationToken))
            {
                tableNames.Add(reader.GetString(0));
            }

            foreach (var tableName in tableNames)
            {
                try
                {
                    await using var dropCommand = new NpgsqlCommand($"DROP TABLE IF EXISTS ext.{tableName} CASCADE", connection);
                    await dropCommand.ExecuteNonQueryAsync(cancellationToken);
                    
                    _logger.LogInformation("Dropped old new table: {TableName}", tableName);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to drop old new table {TableName}: {Error}", tableName, ex.Message);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to cleanup old new tables: {Error}", ex.Message);
        }
    }
}

public class FullSwitchResult
{
    public bool Success { get; set; }
    public string? Error { get; set; }
    public long ImportedRows { get; set; }
    public string? NewTableName { get; set; }
    public string? BackupTableName { get; set; }
    public TimeSpan Duration { get; set; }
}