# 設計検討Q&A - PgPostalCodeSync

**作成日:** 2025-08-30 (JST)  
**目的:** 設計検討過程で提起された疑問点と採用理由をまとめる

---

## 1. 技術選択に関するQ&A

### Q: NuGetパッケージの具体的なバージョン指定は必要か？
**A: 不要（最新版使用）**
- 理由：バージョン記載がない場合は最新安定版を使用するのが一般的
- メリット：最新の機能・セキュリティ修正を利用可能
- リスク：破壊的変更はメジャーバージョンアップ時のみなので、通常問題なし

**使用ライブラリ:**
- **Aloe.Utils.CommandLine** (コマンドライン引数解析) - 最新: 1.0.4

### Q: Entity Framework Coreを必須で使用するか？
**A: 不要（Npgsqlのみで十分）**
- 理由：COPY FROM STDINは生のNpgsql APIが最適
- メリット：効率重視、不要な抽象化レイヤーを排除
- 判断基準：郵便番号データの取り込み処理は単純なCRUD操作のため

### Q: アプリケーション構成はどうするか？
**A: ConsoleApp + DI + 汎用ホスト**
- 理由：.NET 6以降の標準的なConsoleApp構成
- メリット：設定ファイル読み込み、DI、Serilog統合が標準で利用可能
- 実装：`Host.CreateDefaultBuilder()` + `ConfigureServices()`

---

## 2. 設定・構成に関するQ&A

### Q: Optionsパターンは必要か？
**A: 不要（都度実行アプリのため）**
- 理由：長時間稼働するサービスではないため、型安全性のメリットが限定的
- 代替：`IConfiguration`から直接読み取りで十分
- 判断基準：シンプル性を優先

### Q: HTTPダウンロードでリトライ機能は必要か？
**A: 不要（都度実行のため）**
- 理由：スケジューラで定期実行されるため、失敗時は次回実行で対応
- メリット：実装をシンプルに保つ
- 運用：エラー時はログ出力し、外部監視で対応

### Q: SSL証明書検証は独自で管理するか？
**A: 不要（標準のHttpClientに任せる）**
- 理由：日本郵便の公式HTTPSサイトは適切な証明書を使用
- メリット：標準的なセキュリティ実装を維持
- リスク：独自実装はセキュリティホールを生む可能性

---

## 3. データ処理に関するQ&A

### Q: CSVパーサーは独自実装するか？
**A: 不要（COPY FROM STDINに直接投入）**
- 理由：効率重視、PostgreSQLのCSVパーサーが高性能
- メリット：メモリ使用量削減、処理速度向上
- 実装：HttpClientのStreamを直接Npgsqlに渡す

### Q: 引用符処理はどう実装するか？
**A: PostgreSQLのCOPYオプションで対応**
```sql
WITH (FORMAT CSV, DELIMITER ',', QUOTE '"', ESCAPE '"')
```
- 理由：日本郵便CSV仕様（2～9列が引用符囲み）に対応
- メリット：標準機能で確実な処理

### Q: アプリケーション終了コードは詳細に分ける必要があるか？
**A: 不要（0=成功、0以外=エラー）**
- 理由：詳細なエラー情報はログで確認するため
- メリット：シンプルな運用、スケジューラとの連携が容易
- 判断基準：KISS原則（Keep It Simple, Stupid）

---

## 4. PostgreSQL拡張機能に関するQ&A

### Q: pg_stat_statementsなど分析用拡張は必要か？
**A: 不要（要件対象外）**
- 理由：性能分析は今回の要件ではない
- 判断基準：郵便番号取り込み処理に直接関係しない

### Q: unaccent（アクセント記号削除）は必要か？
**A: 不要（日本語データのため）**
- 理由：日本の郵便番号・住所データにアクセント記号は存在しない
- 例：éやñなどの文字は日本郵便CSVに含まれない

### Q: UUID拡張は必要か？
**A: 不要（現在のスキーマでUUID未使用）**
- 理由：主キーはBIGINT IDENTITY、外部システム連携でUUID不要
- 将来性：必要になった時点で追加すればよい

### Q: pgvector（ベクター検索）は必要か？
**A: 不要（住所検索要件なし）**
- 理由：単純な郵便番号データ取り込み処理のみ
- 判断基準：要件に含まれない機能は実装しない

---

## 5. データベース設計に関するQ&A

### Q: 外部キー制約は設定すべきか？
**A: 設定する（データ整合性のため）**
```sql
ALTER TABLE ext.ingestion_files 
  ADD CONSTRAINT fk_ingestion_files_run_id 
  FOREIGN KEY (run_id) REFERENCES ext.ingestion_runs(run_id);
```
- 理由：データ整合性保証、運用ミスの防止
- パフォーマンス：取り込み処理への影響は軽微

### Q: すべてのCSV列を本番テーブルに保存するか？
**A: 必要な列のみ保存**
- 保存対象：郵便番号、都道府県名、市区町村名、町域名（漢字・カナ）
- 除外対象：フラグ列（is_multi_zip等）、更新関連列
- 理由：検索・参照で使用する列のみに限定してシンプル化

---

## 6. 運用・保守に関するQ&A

### Q: 多重起動防止は実装するか？
**A: 不要（外部スケジューラで管理）**
- 理由：cronやタスクスケジューラで実行間隔を制御
- メリット：アプリケーションロジックをシンプルに保つ
- 代替：必要に応じてスケジューラ側で同時実行制限

### Q: 詳細なログレベル設定は必要か？
**A: Information/Warning/Errorで十分**
- 理由：Debug/Traceレベルの情報は通常運用で不要
- 設定：本番ではInformation以上、開発時はDebug可能
- 判断基準：ログ量と有用性のバランス

### Q: 設定ファイルのバリデーションは厳密に行うか？
**A: 最小限（必須項目のnullチェック程度）**
- 理由：不正な設定は実行時エラーで十分検知可能
- メリット：実装コスト削減
- 運用：設定ミスは初回実行時に発見される

---

## 7. アーキテクチャに関するQ&A

### Q: IHostedServiceパターンは必要か？
**A: 不要（単発実行のため）**
- 理由：長時間稼働するサービスではない
- 実装：Main()メソッドで直線的な処理フロー
- メリット：理解しやすいコード構造

### Q: Repository/Service層の分離は必要か？
**A: 最小限（データアクセス層程度）**
- 実装：直接Npgsql操作を薄くラップする程度
- 理由：複雑なビジネスロジックがないため
- 判断基準：YAGNI原則（You Aren't Gonna Need It）

---

## 8. セキュリティに関するQ&A

### Q: 接続文字列の暗号化は必要か？
**A: 環境変数での管理を推奨**
- 理由：設定ファイルへのパスワード記載を避ける
- 実装：`Environment.GetEnvironmentVariable()`で読み取り
- 運用：デプロイ時に環境変数設定

### Q: SQLインジェクション対策は必要か？
**A: パラメータクエリ使用で対応**
- 理由：ユーザー入力はCLI引数のみで限定的
- 実装：NpgsqlCommandのParametersを使用
- 対象：YYMM文字列の埋め込み部分

---

## まとめ

設計方針として**シンプル性と効率性を重視**し、過度な機能実装を避けることで：

1. **保守性向上**：理解しやすいコード
2. **性能向上**：不要な抽象化を排除
3. **信頼性向上**：複雑性によるバグ混入を防止
4. **開発効率**：要件に集中した実装

これらの判断基準に基づいて最終設計を決定している。